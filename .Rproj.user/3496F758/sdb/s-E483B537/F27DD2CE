{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Project 4\"\nauthor: \"October 5, 2016\"\ndate: \"Due October 7, 2016 at 11:59pm\"\noutput:\n  html_document\n\n\n---\n\n<style type=\"text/css\">\n.table {\n\n    width: 80%;\n    margin-left:10%; \n    margin-right:10%;\n}\n</style>\n```{r,setup, echo=FALSE, cache=TRUE}\n## numbers >= 10^5 will be denoted in scientific notation,\n## and rounded to 2 digits\noptions(scipen = 3, digits = 3)\n```\n\n\n\n\n#Project Goals:\n\nThe goal of this project is to get aquainted with the Rstudio server as well as to work on creating functions. You will do some function refactoring as well.[Lab 4 - Markdown](https://canvas.brown.edu/files/60622922/download?download_frd=1)\n\n\n# Part I: Function Building with the jackknife function\n\n\n## Jackknife of the Mean!\n\n- Have an estimator $\\hat{\\theta}$ of parameter $\\theta$  \n  want the standard error of our estimate, $se_{\\hat{\\theta}}$\n- The jackknife approximation:\n    + omit case $i$, get estimate $\\hat{\\theta}_{(-i)}$\n    + Take the variance of all the $\\hat{\\theta}_{(-i)}$\n    + multiply that variance by $\\frac{(n-1)^2}{n}$ to get $\\approx$ variance of $\\hat{\\theta}$\n- then $se_{\\hat{\\theta}}=$ square root of that variance\n\n<small>(Why $(n-1)^2 / n$?  Think about just getting the standard\n    error of the mean)</small>\n\n\n\nWrite a function called `mean.jackknife` that takes argument `a_vector` and returns a jackknife estimate of the standard error.\n\n\n```{r, eval=FALSE}\nmean.jackknife <- function(a_vector) {\n  # Put your function in here\n  return(jackknife.stderr)\n}\n```\n\n\n\n#### Jackknife for the mean Example: test your code here\n\n\n```{r, eval = FALSE}\nsome_normals <- rnorm(100,mean=7,sd=5)\nmean(some_normals)\n(formula_se_of_mean <- sd(some_normals)/sqrt(length(some_normals)))\nall.equal(formula_se_of_mean,mean.jackknife(some_normals))\n```\n\n\n\n##Jackknife for Gamma Parameters\n\n\nRecall our friend the method of moments estimator:\n\n```{r, eval=FALSE}\ngamma.est <- function(the_data) {\n  m <- mean(the_data)\n  v <- var(the_data)\n  a <- m^2/v\n  s <- v/m\n  return(c(a=a,s=s))\n}\n```\n\n\n###Jackknife for Gamma Parameters Function\n\nWrite a function called `gamma.jackknife` that takes argument `a_vector` and returns jackknife standard error estimates on the gamma parameters. \n\n```{r, eval=FALSE }\ngamma.jackknife <- function(a_vector) {\n  \n  return(jackknife.stderrs)\n}\n```\n\n\n\n###Jackknife for Gamma Parameters Example\n\n\n```{r, eval=FALSE}\ninput <- rgamma(1000, shape=0.1, scale=10)\ngamma.est(input)\ngamma.jackknife(input)\n```\n\n\n\n##Jackknife for linear regression coefficients\n\nWrite a function called `jackknife.lm` that takes arguments `df`, `formula` and `p` and returns jackknife standard error estimates on the coefficients of a linear regression model. \n\n```{r, eval=FALSE}\njackknife.lm <- function(df,formula,p) {\n  \n  return(jackknife.stderr)\n}\n```\n\n\n\n###Jackknife for linear regression coefficients Example\n\n\n```{r, eval=FALSE}\noutput <- 1.2 + 0.6*input +  rnorm(1000, 0, 2.1)\ndata <- data.frame(output,input)\nmy.lm <- lm(output~input, data=data)\ncoefficients(my.lm)\n# \"Official\" standard errors\nsqrt(diag(vcov(my.lm)))\njackknife.lm(df=data,formula=\"output~input\",p=2)\n```\n\n\n\n\n##Refactoring the Jackknife\n\n\n- Omitting one point or row is a common sub-task\n\n- The general pattern:\n\n```\nfigure out the size of the data\nfor each case\n   omit that case\n   repeat some estimation and get a vector of numbers\ntake variances across cases\nscale up variances\ntake the square roots\n```\n\n- Refactor by extracting the common \"omit one\" operation\n\n- Refactor by defining a general \"jackknife\" operation\n\n\n\n###The Common Operation\n\n\n- _Problem_: Omit one particular data point from a larger structure\n\n- _Difficulty_: Do we need a comma in the index or not?\n\n- _Solution_: Works for vectors, lists, 1D and 2D arrays, matrices, data frames:\n\n\n\n## Goal: \n\n\n- Make the function select the correct dimensions\n    - length for a 1d object\n    - number of rows for 2d\n- Write a function `omit.case` that omits a point given the data and returns the data minus that point. Make sure it can handle higher dimensions. \n    ```{r, eval=FALSE}\n          omit.case <- function(the_data,omitted_point) {\n        # This should take the data and omit one point at a time and return the new data\n            }\n    ```\n- Write a function `omit_and_est` that takes the data with an omitted point and returns whatever function your estimator does.  \n    ```{r,eval=FALSE}\n    \n        omit_and_est <- function(omit) {\n              # This function should take the output of omit.case and use it as input for the estimator\n        }\n\n\n```{r, eval=FALSE}\njackknife <- function(estimator,the_data) {\n  \n  # Define n to be lenth or number of rows here\n  \n  \n  \n  jackknife.ests <- matrix(sapply(1:n, omit_and_est), ncol=n)\n  var.of.reestimates <- apply(jackknife.ests,1,var)\n  jackknife.var <- ((n-1)^2/n)* var.of.reestimates\n  jackknife.stderr <- sqrt(jackknife.var)\n  return(jackknife.stderr)\n}\n```\n\n\n\n---\n\n###It works\n\n\n```{r, eval=FALSE}\njackknife(estimator=mean,the_data=some_normals)\nall.equal(jackknife(estimator=mean,the_data=some_normals),\n          mean.jackknife(some_normals))\n```\n\n---\n\n\n\n```{r, eval=FALSE}\nall.equal(jackknife(estimator=gamma.est,the_data=data$input),\n          gamma.jackknife(data$input))\n```\n\n---\n\n\n```{r, eval=FALSE}\nall.equal(jackknife(estimator=gamma.est,the_data=data$input),\n          gamma.jackknife(data$input), check.names=FALSE)\n```\n\n\n```{r, eval=FALSE}\nest.coefs <- function(the_data) {\n  return(lm(output~input,data=the_data)$coefficients)\n}\nest.coefs(data)\nall.equal(est.coefs(data), coefficients(my.lm))\n```\n\n---\n\n\n```{r, eval=FALSE}\njackknife(estimator=est.coefs,the_data=data)\nall.equal(jackknife(estimator=est.coefs,the_data=data),\n          jackknife.lm(df=data,formula=\"output~input\",p=2))\n```\n\n\n##Further Refactoring of jackknife()\n\n\nThe code for `jackknife()` is still a bit clunky:\n- Ugly `if-else` for finding `n`\n- Bit at the end for scaling variances down to standard errors\n\n- write a function that calculates the `n` needed for the above code:\n\n    ```{r, eval=FALSE}\n      data_size <- function(the_data) {\n  \n      }\n    ```\n- Write a funcrion that calculate the variance of all the estimates and returns the standard error\n```{r, eval=FALSE}\nscale_and_sqrt_vars <- function(jackknife.ests,n) {\n  \n  return(jackknife.stderr)\n}\n```\n\n\n\n###Now invoke those functions\n\n```{r, eval=FALSE}\njackknife <- function(estimator,the_data) {\n  n <- data_size(the_data)\n  omit_and_est <- function(omit) {\n    estimator(omit.case(the_data,omit))\n  }\n  jackknife.ests <- matrix(sapply(1:n, omit_and_est), ncol=n)\n  return(scale_and_sqrt_vars(jackknife.ests,n))\n}\n```\n\n",
    "created" : 1488808136749.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "767751686",
    "id" : "F27DD2CE",
    "lastKnownWriteTime" : 1475684150,
    "last_content_update" : 1475684150,
    "path" : "C:/Users/adam_/Dropbox/Brown/PHP2560/Fall - 2016/Project/project4.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}