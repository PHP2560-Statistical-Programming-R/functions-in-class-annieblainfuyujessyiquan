{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Untitled\"\nauthor: \"\"\ndate: \"March 7, 2017\"\noutput: html_document\n---\n\n\n##Jackknife for Gamma Parameters\n\n\nRecall our friend the method of moments estimator:\n\n```{r, eval=FALSE}\ngamma.est <- function(the_data) {\n  m <- mean(the_data)\n  v <- var(the_data)\n  a <- m^2/v\n  s <- v/m\n  return(c(a=a,s=s))\n}\n```\n\n\n###Jackknife for Gamma Parameters Function\n\nWrite a function called `gamma.jackknife` that takes argument `a_vector` and returns jackknife standard error estimates on the gamma parameters. \n\n```{r, eval=FALSE }\ngamma.jackknife <- function(a_vector) {\n  \n  return(jackknife.stderrs)\n}\n```\n\n\n\n###Jackknife for Gamma Parameters Example\n\n\n```{r, eval=FALSE}\ninput <- rgamma(1000, shape=0.1, scale=10)\ngamma.est(input)\ngamma.jackknife(input)\n```\n\n\n\n##Jackknife for linear regression coefficients\n\nWrite a function called `jackknife.lm` that takes arguments `df`, `formula` and `p` and returns jackknife standard error estimates on the coefficients of a linear regression model. \n\n```{r, eval=FALSE}\njackknife.lm <- function(df,formula,p) {\n  \n  return(jackknife.stderr)\n}\n```\n\n\n\n###Jackknife for linear regression coefficients Example\n\n\n```{r, eval=FALSE}\noutput <- 1.2 + 0.6*input +  rnorm(1000, 0, 2.1)\ndata <- data.frame(output,input)\nmy.lm <- lm(output~input, data=data)\ncoefficients(my.lm)\n# \"Official\" standard errors\nsqrt(diag(vcov(my.lm)))\njackknife.lm(df=data,formula=\"output~input\",p=2)\n```\n\n\n\n\n##Refactoring the Jackknife\n\n\n- Omitting one point or row is a common sub-task\n\n- The general pattern:\n\n```\nfigure out the size of the data\nfor each case\n   omit that case\n   repeat some estimation and get a vector of numbers\ntake variances across cases\nscale up variances\ntake the square roots\n```\n\n- Refactor by extracting the common \"omit one\" operation\n\n- Refactor by defining a general \"jackknife\" operation\n\n\n\n###The Common Operation\n\n\n- _Problem_: Omit one particular data point from a larger structure\n\n- _Difficulty_: Do we need a comma in the index or not?\n\n- _Solution_: Works for vectors, lists, 1D and 2D arrays, matrices, data frames:\n\n\n\n## Goal: \n\n\n- Make the function select the correct dimensions\n    - length for a 1d object\n    - number of rows for 2d\n- Write a function `omit.case` that omits a point given the data and returns the data minus that point. Make sure it can handle higher dimensions. \n    ```{r, eval=FALSE}\n          omit.case <- function(the_data,omitted_point) {\n        # This should take the data and omit one point at a time and return the new data\n            }\n    ```\n- Write a function `omit_and_est` that takes the data with an omitted point and returns whatever function your estimator does.  \n    ```{r,eval=FALSE}\n    \n        omit_and_est <- function(omit) {\n              # This function should take the output of omit.case and use it as input for the estimator\n        }\n\n\n```{r, eval=FALSE}\njackknife <- function(estimator,the_data) {\n  \n  # Define n to be lenth or number of rows here\n  \n  \n  \n  jackknife.ests <- matrix(sapply(1:n, omit_and_est), ncol=n)\n  var.of.reestimates <- apply(jackknife.ests,1,var)\n  jackknife.var <- ((n-1)^2/n)* var.of.reestimates\n  jackknife.stderr <- sqrt(jackknife.var)\n  return(jackknife.stderr)\n}\n```\n\n\n\n---\n\n###It works\n\n\n```{r, eval=FALSE}\njackknife(estimator=mean,the_data=some_normals)\nall.equal(jackknife(estimator=mean,the_data=some_normals),\n          mean.jackknife(some_normals))\n```\n\n---\n\n\n\n```{r, eval=FALSE}\nall.equal(jackknife(estimator=gamma.est,the_data=data$input),\n          gamma.jackknife(data$input))\n```\n\n---\n\n\n```{r, eval=FALSE}\nall.equal(jackknife(estimator=gamma.est,the_data=data$input),\n          gamma.jackknife(data$input), check.names=FALSE)\n```\n\n\n```{r, eval=FALSE}\nest.coefs <- function(the_data) {\n  return(lm(output~input,data=the_data)$coefficients)\n}\nest.coefs(data)\nall.equal(est.coefs(data), coefficients(my.lm))\n```\n\n---\n\n\n```{r, eval=FALSE}\njackknife(estimator=est.coefs,the_data=data)\nall.equal(jackknife(estimator=est.coefs,the_data=data),\n          jackknife.lm(df=data,formula=\"output~input\",p=2))\n```\n\n\n##Further Refactoring of jackknife()\n\n\nThe code for `jackknife()` is still a bit clunky:\n- Ugly `if-else` for finding `n`\n- Bit at the end for scaling variances down to standard errors\n\n- write a function that calculates the `n` needed for the above code:\n\n    ```{r, eval=FALSE}\n      data_size <- function(the_data) {\n  \n      }\n    ```\n- Write a funcrion that calculate the variance of all the estimates and returns the standard error\n```{r, eval=FALSE}\nscale_and_sqrt_vars <- function(jackknife.ests,n) {\n  \n  return(jackknife.stderr)\n}\n```\n\n\n\n###Now invoke those functions\n\n```{r, eval=FALSE}\njackknife <- function(estimator,the_data) {\n  n <- data_size(the_data)\n  omit_and_est <- function(omit) {\n    estimator(omit.case(the_data,omit))\n  }\n  jackknife.ests <- matrix(sapply(1:n, omit_and_est), ncol=n)\n  return(scale_and_sqrt_vars(jackknife.ests,n))\n}\n```\n\n",
    "created" : 1488808383737.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2572390555",
    "id" : "ACCC58C7",
    "lastKnownWriteTime" : 1488808450,
    "last_content_update" : 1488808450191,
    "path" : "C:/Users/adam_/Dropbox/Brown/PHP2560/Spring2017/Project/Jackknife-Function-R/jackknife_function_R.Rmd",
    "project_path" : "jackknife_function_R.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}